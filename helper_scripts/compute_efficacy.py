#!/usr/bin/env python3
"""
File implements a script where the user can match their own prioritization ordering of
individuals with their actual infection counts based on tranmission history data.
"""

import scipy.stats as stats 
import math
import argparse

from efficacyFunctions import *


# parse user arguments  [-h] -m METRIC [-i INPUT] [-o OUTPUT] [-t TRANMSISSIONHIST] [-c CONTACTNET] -s START [-e END]
parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument('-m', '--metric', required=True, type=float, help="Metric of prioritization (1-6)")
parser.add_argument('-i', '--input', required=False, type=str, default='stdin', help="Input File - User's Ordering")
parser.add_argument('-o', '--output', required=False, type=str, default='stdout', help="Output File")
parser.add_argument('-t', '--tranmsissionHist', required=False, type=str, default='', help='Tranmission History File')
parser.add_argument('-c', '--contactNet', required=False, type=str, default='',  help='Contact History File')
parser.add_argument('-s', '--start', required=True, type=float, help='Time Start')
parser.add_argument('-e', '--end', required=False, type=float, default=float('inf'), help='Time End') # end defaults to infinity
args = parser.parse_args()

# handle input and and output, save into infile and outfile vars
if args.input == 'stdin':
    from sys import stdin; order = [l.strip() for l in stdin]
elif args.input.lower().endswith('.gz'):
    from gzip import open as gopen; order = [l.strip() for l in gopen(args.input).read().decode().strip().splitlines()]
else:
    order = [l.strip() for l in open(args.input).read().strip().splitlines()]
if args.output == 'stdout':
    from sys import stdout; outfile = stdout
else:
    outfile = open(args.output,'w')

# Create a dictionary matching individuals to infection counts using tranmission history data
infectionsDict = pairCounts(args.tranmsissionHist, args.contactNet, args.start, args.end, args.metric)

# Read the user's ordering and print a file with individuals and their counts in the same order
matchInfectorCounts(infectionsDict, order, outfile, args.metric)
outfile.close()


def calculateTauB(userOrder, outfile, reverse: bool) -> None:
        """
        Calculates the Kendall Tau B correlation coefficient between user ordering
        and most optimal ordering, assuming that the an ascending count starting
        from 0 is the most optimal.
        (ex: for an ordering containing 3 people, the optimal ordering would be [0,1,2])

        Outputs coefficient and pvalue in the following format: "<tau> <pvalue>".
        Returns void.

        Parameters
        ----------
        userOrder- an ordering of infectors and their counts
                   - generated by the user's algorithm
        outfile - the file the tau and pvalue are outputted
        reverse - bool, true if user's ordering is compared to an order sorted descending,
                                        false if comparing to an order sorted ascending
        """

        optimalOrder = []

        if not reverse:
            optimalOrder = list(range(len(userOrder), 0, -1))
        else:
            optimalOrder = list(range(len(userOrder)))

        tau, pvalue = stats.kendalltau(optimalOrder, userOrder)

        outfile.write("%s\t%s\n" % (tau, pvalue))


# Iterate over all the lines for efficacy
for i in range(len(efficacy)):
    if len(efficacy[i]) != 2:
        raise ValueError("Input must be efficacy file as generated by ./compute_efficacy (TSV with 2 columns: PERSON<TAB>EFFICACY", efficacy)
    efficacy[i] = float(efficacy[i][1])

ascendingSort = False
# user wants to compare their ordering theirs sorted in ascending order

calculateTauB(efficacy, outfile, ascendingSort)
outfile.close()